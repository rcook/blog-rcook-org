---
layout: post
title: An algebraic data type in Scala
created: 2019-02-19 09:39:00 -0800
tags:
- Scala
---

{% gist fbff15bac509bd71bf8ba0d174a905ce ADTs.scala %}

That's a lot of typing. "The world's most verbose sum types", as someone once said.

But, at least I can pattern-match on it!

Surprisingly, the Haskell version _isn't_ significantly shorter in terms of line count.

{% gist fbff15bac509bd71bf8ba0d174a905ce ADTs.hs %}

Though there is less line noise.

**Update: 2019-02-20**

Here's another side-by-side comparison of an extension to my simple expression language embedded in an algebraic data type:

Scala (using [Scalaz][scalaz]):

{% gist dd4db779353cde36646c3a78736ebb2d Expr.scala %}

Haskell:

{% gist dd4db779353cde36646c3a78736ebb2d Expr.hs %}

The two pieces of code look remarkably similar. Haskell has a much more compact (and, in my opinion, intuitive) way of defining the `Expr` sum type. Haskell's `Applicative` (baked into `Prelude`) provides the elegance of `<$>` and `<*>` but, other than that, they're clearly similar. The `flatMap`/`for`-comprehension vs. `do`-notation is eerily similar, in fact.

[scalaz]: https://github.com/scalaz/scalaz
